{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Welcome to bltools","text":"<p>Modern Async Downloader for British Library Manuscripts</p> <p><code>bltools</code> is a high-performance Python CLI tool designed to download manuscript images from the British Library's viewer. It utilizes <code>asyncio</code> and <code>httpx</code> for fast, parallel downloading and <code>Typer</code> for a robust command-line interface.</p>"},{"location":"#key-features","title":"Key Features","text":"<ul> <li>Blazing Fast: Uses <code>asyncio</code> + <code>httpx</code> to download tiles in parallel.</li> <li>Robust: Automatic retries with exponential backoff via <code>tenacity</code>.</li> <li>Beautiful: Rich terminal output with progress bars and spinners.</li> <li>Developer Friendly: Strictly typed, documented, and fully tested.</li> </ul>"},{"location":"#installation","title":"Installation","text":"<p>Requires Python 3.9+.</p>"},{"location":"#using-uv-recommended","title":"Using uv (Recommended)","text":"<pre><code>uv tool install bltools\n# or run directly\nuv run bltools --help\n</code></pre>"},{"location":"#using-pip","title":"Using pip","text":"<pre><code>pip install bltools\n</code></pre>"},{"location":"#quick-start","title":"Quick Start","text":"<p>Download pages 1 to 5 of a manuscript:</p> <pre><code>bltools download add_ms_19352 --range 1-5\n</code></pre> <p>Save to a specific directory:</p> <pre><code>bltools download add_ms_19352 --output ./downloads\n</code></pre>"},{"location":"api/","title":"API Reference","text":""},{"location":"api/#cli-application","title":"CLI Application","text":""},{"location":"api/#bltools.main","title":"<code>bltools.main</code>","text":""},{"location":"api/#bltools.main.download","title":"<code>download(input_str=typer.Argument(..., help='Manuscript ID (e.g., add_ms_19352) or IIIF Manifest URL'), output=typer.Option(None, '--output', '-o', help='Directory to save downloads'), range=typer.Option(None, '--range', help='Page range to download (e.g., 1-10)'), verbose=typer.Option(False, '--verbose', help='Enable debug logging'))</code>","text":"<p>Download a manuscript from the British Library.</p> <p>Supports legacy Manuscript IDs (tiled downloads) and modern IIIF Manifest URLs (direct high-resolution downloads).</p> <p>Parameters:</p> Name Type Description Default <code>input_str</code> <code>str</code> <p>Manuscript ID or IIIF Manifest URL.</p> <code>Argument(..., help='Manuscript ID (e.g., add_ms_19352) or IIIF Manifest URL')</code> <code>output</code> <code>Optional[Path]</code> <p>Optional override for the output directory.</p> <code>Option(None, '--output', '-o', help='Directory to save downloads')</code> <code>range</code> <code>Optional[str]</code> <p>Optional page range (e.g., 1-10).</p> <code>Option(None, '--range', help='Page range to download (e.g., 1-10)')</code> <code>verbose</code> <code>bool</code> <p>Enable debug-level logging.</p> <code>Option(False, '--verbose', help='Enable debug logging')</code> Source code in <code>src\\bltools\\main.py</code> <pre><code>@app.command()\ndef download(\n    input_str: str = typer.Argument(\n        ..., help=\"Manuscript ID (e.g., add_ms_19352) or IIIF Manifest URL\"\n    ),\n    output: Optional[Path] = typer.Option(\n        None, \"--output\", \"-o\", help=\"Directory to save downloads\"\n    ),\n    range: Optional[str] = typer.Option(\n        None, \"--range\", help=\"Page range to download (e.g., 1-10)\"\n    ),\n    verbose: bool = typer.Option(False, \"--verbose\", help=\"Enable debug logging\"),\n) -&gt; None:\n    \"\"\"\n    Download a manuscript from the British Library.\n\n    Supports legacy Manuscript IDs (tiled downloads) and modern IIIF Manifest URLs\n    (direct high-resolution downloads).\n\n    Args:\n        input_str: Manuscript ID or IIIF Manifest URL.\n        output: Optional override for the output directory.\n        range: Optional page range (e.g., 1-10).\n        verbose: Enable debug-level logging.\n    \"\"\"\n    settings = get_settings()\n\n    if verbose:\n        structlog.configure(wrapper_class=structlog.make_filtering_bound_logger(20))\n\n    if output:\n        settings.basedir = output\n\n    try:\n        asyncio.run(download_manuscript(input_str, settings, console, range))\n    except Exception as e:\n        console.print(f\"[bold red]Error:[/bold red] {e}\")\n        if verbose:\n            raise e\n        raise typer.Exit(code=1) from None\n</code></pre>"},{"location":"api/#bltools.main.main","title":"<code>main()</code>","text":"<p>British Library Manuscript Downloader CLI.</p> Source code in <code>src\\bltools\\main.py</code> <pre><code>@app.callback()\ndef main() -&gt; None:\n    \"\"\"British Library Manuscript Downloader CLI.\"\"\"\n    pass\n</code></pre>"},{"location":"api/#core-logic","title":"Core Logic","text":""},{"location":"api/#bltools.core","title":"<code>bltools.core</code>","text":""},{"location":"api/#bltools.core.download_image","title":"<code>download_image(client, url)</code>  <code>async</code>","text":"<p>Download an image with exponential backoff retries.</p> <p>Parameters:</p> Name Type Description Default <code>client</code> <code>AsyncClient</code> <p>The HTTP client to use.</p> required <code>url</code> <code>str</code> <p>URL of the image.</p> required <p>Returns:</p> Name Type Description <code>bytes</code> <code>bytes</code> <p>The image content.</p> Source code in <code>src\\bltools\\core.py</code> <pre><code>@retry(\n    stop=stop_after_attempt(5),\n    wait=wait_exponential(multiplier=1, min=1, max=10),\n    retry=retry_if_exception_type((httpx.RequestError, httpx.HTTPStatusError)),\n)\nasync def download_image(client: httpx.AsyncClient, url: str) -&gt; bytes:\n    \"\"\"\n    Download an image with exponential backoff retries.\n\n    Args:\n        client: The HTTP client to use.\n        url: URL of the image.\n\n    Returns:\n        bytes: The image content.\n    \"\"\"\n    response = await client.get(url)\n    response.raise_for_status()\n    return response.content\n</code></pre>"},{"location":"api/#bltools.core.download_manuscript","title":"<code>download_manuscript(input_str, settings, console, range_str=None)</code>  <code>async</code>","text":"<p>Download a manuscript given a IIIF Manifest URL or a legacy ID.</p> <p>Parameters:</p> Name Type Description Default <code>input_str</code> <code>str</code> <p>IIIF Manifest URL or legacy manuscript ID.</p> required <code>settings</code> <code>Settings</code> <p>Application settings.</p> required <code>console</code> <code>Console</code> <p>Rich console object.</p> required <code>range_str</code> <code>Optional[str]</code> <p>Optional range string (e.g., 1-10).</p> <code>None</code> Source code in <code>src\\bltools\\core.py</code> <pre><code>async def download_manuscript(\n    input_str: str,\n    settings: Settings,\n    console: Console,\n    range_str: Optional[str] = None,\n) -&gt; None:\n    \"\"\"\n    Download a manuscript given a IIIF Manifest URL or a legacy ID.\n\n    Args:\n        input_str: IIIF Manifest URL or legacy manuscript ID.\n        settings: Application settings.\n        console: Rich console object.\n        range_str: Optional range string (e.g., 1-10).\n    \"\"\"\n    is_url = input_str.startswith(\"http\")\n    log = logger.bind(input=input_str)\n\n    async with httpx.AsyncClient(\n        headers={\"User-Agent\": \"Mozilla/5.0\"}, timeout=60.0, follow_redirects=True\n    ) as client:\n        if is_url:\n            log.info(\"iiif_mode_detected\")\n            manifest = await fetch_manifest(input_str)\n            # Use manuscript ID from manifest or URL if possible\n            folder_name = input_str.split(\"/\")[-1] or \"download\"\n            target_dir = settings.basedir / folder_name\n            target_dir.mkdir(parents=True, exist_ok=True)\n\n            items = manifest.items\n            if range_str:\n                try:\n                    start, end = map(int, range_str.split(\"-\"))\n                    items = items[start - 1 : end]\n                except (ValueError, IndexError):\n                    log.error(\"invalid_range_format\", range=range_str)\n                    raise ValueError(\n                        f\"Invalid range format: {range_str}. Use start-end (e.g., 1-10)\"\n                    ) from None\n\n            with Progress(\n                SpinnerColumn(),\n                TextColumn(\"[progress.description]{task.description}\"),\n                BarColumn(),\n                TextColumn(\"[progress.percentage]{task.percentage:&gt;3.0f}%\"),\n                console=console,\n            ) as progress:\n                task_id = progress.add_task(\n                    f\"Downloading {len(items)} items...\", total=len(items)\n                )\n                tasks = [\n                    process_iiif_canvas(\n                        client, canvas, i + 1, settings, target_dir, progress, task_id\n                    )\n                    for i, canvas in enumerate(items)\n                ]\n                await asyncio.gather(*tasks)\n        else:\n            log.info(\"legacy_mode_detected\")\n            manuscript_id = input_str\n            start, end = (settings.rangebegin, settings.rangeend)\n            if range_str:\n                try:\n                    start, end = map(int, range_str.split(\"-\"))\n                except ValueError:\n                    log.error(\"invalid_range_format\", range=range_str)\n                    raise ValueError(\n                        f\"Invalid range format: {range_str}. Use start-end (e.g., 1-10)\"\n                    ) from None\n\n            target_dir = settings.basedir / manuscript_id\n            target_dir.mkdir(parents=True, exist_ok=True)\n\n            pages = []\n            for i in range(start, end + 1):\n                pages.append((i, \"r\"))\n                pages.append((i, \"v\"))\n\n            with Progress(\n                SpinnerColumn(),\n                TextColumn(\"[progress.description]{task.description}\"),\n                BarColumn(),\n                TextColumn(\"[progress.percentage]{task.percentage:&gt;3.0f}%\"),\n                console=console,\n            ) as progress:\n                task_id = progress.add_task(\n                    f\"Downloading {len(pages)} pages...\", total=len(pages)\n                )\n                # Legacy mode uses smaller batches to avoid overwhelming the server\n                chunk_size = 5\n                for i in range(0, len(pages), chunk_size):\n                    chunk = pages[i : i + chunk_size]\n                    batch_tasks = [\n                        process_legacy_page(\n                            client,\n                            manuscript_id,\n                            p,\n                            s,\n                            settings,\n                            target_dir,\n                            progress,\n                            task_id,\n                        )\n                        for p, s in chunk\n                    ]\n                    await asyncio.gather(*batch_tasks)\n\n    log.info(\"download_complete\")\n</code></pre>"},{"location":"api/#bltools.core.fetch_manifest","title":"<code>fetch_manifest(url)</code>  <code>async</code>","text":"<p>Fetch and parse a IIIF manifest from a URL.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>The URL of the IIIF manifest.</p> required <p>Returns:</p> Name Type Description <code>IIIFManifest</code> <code>IIIFManifest</code> <p>The parsed manifest object.</p> Source code in <code>src\\bltools\\core.py</code> <pre><code>async def fetch_manifest(url: str) -&gt; IIIFManifest:\n    \"\"\"\n    Fetch and parse a IIIF manifest from a URL.\n\n    Args:\n        url: The URL of the IIIF manifest.\n\n    Returns:\n        IIIFManifest: The parsed manifest object.\n    \"\"\"\n    async with httpx.AsyncClient(follow_redirects=True) as client:\n        res = await client.get(url)\n        res.raise_for_status()\n        return IIIFManifest.model_validate(res.json())\n</code></pre>"},{"location":"api/#bltools.core.get_file_info","title":"<code>get_file_info(client, manuscript_id, filename, settings)</code>  <code>async</code>","text":"<p>Fetch the XML metadata for a page to determine dimensions and tile size.</p> <p>Parameters:</p> Name Type Description Default <code>client</code> <code>AsyncClient</code> <p>The HTTP client to use.</p> required <code>manuscript_id</code> <code>str</code> <p>The ID of the manuscript.</p> required <code>filename</code> <code>str</code> <p>The specific filename (e.g., f001r.jpg).</p> required <code>settings</code> <code>Settings</code> <p>Application settings.</p> required <p>Returns:</p> Type Description <code>tuple[int, int, int]</code> <p>tuple[int, int, int]: Width, height, and tile size.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If metadata cannot be parsed.</p> Source code in <code>src\\bltools\\core.py</code> <pre><code>async def get_file_info(\n    client: httpx.AsyncClient, manuscript_id: str, filename: str, settings: Settings\n) -&gt; tuple[int, int, int]:\n    \"\"\"\n    Fetch the XML metadata for a page to determine dimensions and tile size.\n\n    Args:\n        client: The HTTP client to use.\n        manuscript_id: The ID of the manuscript.\n        filename: The specific filename (e.g., f001r.jpg).\n        settings: Application settings.\n\n    Returns:\n        tuple[int, int, int]: Width, height, and tile size.\n\n    Raises:\n        ValueError: If metadata cannot be parsed.\n    \"\"\"\n    info_url = f\"{settings.baseurl}{manuscript_id}_{filename.split('.')[0]}.xml\"\n    log = logger.bind(manuscript_id=manuscript_id, filename=filename, url=info_url)\n\n    log.debug(\"fetching_metadata\")\n    response = await client.get(info_url)\n    response.raise_for_status()\n\n    try:\n        info_dict = xmltodict.parse(response.content)\n        w = int(info_dict[\"Image\"][\"Size\"][\"@Width\"]) - 1\n        h = int(info_dict[\"Image\"][\"Size\"][\"@Height\"]) - 1\n        t = int(info_dict[\"Image\"][\"@TileSize\"])\n        log.debug(\"metadata_parsed\", width=w, height=h, tile_size=t)\n        return w, h, t\n    except (KeyError, ValueError, Exception) as e:\n        log.error(\"metadata_parse_failed\", error=str(e))\n        raise ValueError(f\"Failed to parse XML for {filename}: {e}\") from e\n</code></pre>"},{"location":"api/#bltools.core.process_iiif_canvas","title":"<code>process_iiif_canvas(client, canvas, index, settings, target_dir, progress, task_id)</code>  <code>async</code>","text":"<p>Download a single IIIF canvas (page).</p> <p>Parameters:</p> Name Type Description Default <code>client</code> <code>AsyncClient</code> <p>The HTTP client to use.</p> required <code>canvas</code> <code>IIIFCanvas</code> <p>The IIIF canvas object.</p> required <code>index</code> <code>int</code> <p>The page index.</p> required <code>settings</code> <code>Settings</code> <p>Application settings.</p> required <code>target_dir</code> <code>Path</code> <p>Directory to save the image.</p> required <code>progress</code> <code>Progress</code> <p>Progress bar object.</p> required <code>task_id</code> <code>TaskID</code> <p>Progress task ID.</p> required Source code in <code>src\\bltools\\core.py</code> <pre><code>async def process_iiif_canvas(\n    client: httpx.AsyncClient,\n    canvas: IIIFCanvas,\n    index: int,\n    settings: Settings,\n    target_dir: Path,\n    progress: Progress,\n    task_id: TaskID,\n) -&gt; None:\n    \"\"\"\n    Download a single IIIF canvas (page).\n\n    Args:\n        client: The HTTP client to use.\n        canvas: The IIIF canvas object.\n        index: The page index.\n        settings: Application settings.\n        target_dir: Directory to save the image.\n        progress: Progress bar object.\n        task_id: Progress task ID.\n    \"\"\"\n    label = (\n        canvas.label\n        if isinstance(canvas.label, str)\n        else canvas.label.get(\"en\", [str(index)])[0]\n    )\n    filename = f\"{index:04d}_{label.replace(' ', '_')}.jpg\"\n    file_path = target_dir / filename\n    log = logger.bind(canvas_id=canvas.id, filename=filename)\n\n    if file_path.exists():\n        progress.update(\n            task_id, advance=1, description=f\"[dim]Skipped {filename}[/dim]\"\n        )\n        log.info(\"canvas_skipped_exists\")\n        return\n\n    url = canvas.get_image_url()\n    if not url:\n        log.error(\"no_image_url_found\")\n        progress.update(task_id, advance=1)\n        return\n\n    try:\n        content = await download_image(client, url)\n        with open(file_path, \"wb\") as f:\n            f.write(content)\n        log.info(\"canvas_downloaded_success\")\n    except Exception as e:\n        log.error(\"canvas_download_failed\", error=str(e))\n        progress.console.print(f\"[red]Error downloading {filename}: {e}[/red]\")\n\n    progress.update(\n        task_id, advance=1, description=f\"[green]Downloaded {filename}[/green]\"\n    )\n</code></pre>"},{"location":"api/#bltools.core.process_legacy_page","title":"<code>process_legacy_page(client, manuscript_id, page_num, side, settings, target_dir, progress, task_id)</code>  <code>async</code>","text":"<p>Process and stitch a legacy Deep Zoom page.</p> <p>Parameters:</p> Name Type Description Default <code>client</code> <code>AsyncClient</code> <p>The HTTP client to use.</p> required <code>manuscript_id</code> <code>str</code> <p>The ID of the manuscript.</p> required <code>page_num</code> <code>int</code> <p>The page number.</p> required <code>side</code> <code>str</code> <p>The side (r/v).</p> required <code>settings</code> <code>Settings</code> <p>Application settings.</p> required <code>target_dir</code> <code>Path</code> <p>Directory to save the image.</p> required <code>progress</code> <code>Progress</code> <p>Progress bar object.</p> required <code>task_id</code> <code>TaskID</code> <p>Progress task ID.</p> required Source code in <code>src\\bltools\\core.py</code> <pre><code>async def process_legacy_page(\n    client: httpx.AsyncClient,\n    manuscript_id: str,\n    page_num: int,\n    side: str,\n    settings: Settings,\n    target_dir: Path,\n    progress: Progress,\n    task_id: TaskID,\n) -&gt; None:\n    \"\"\"\n    Process and stitch a legacy Deep Zoom page.\n\n    Args:\n        client: The HTTP client to use.\n        manuscript_id: The ID of the manuscript.\n        page_num: The page number.\n        side: The side (r/v).\n        settings: Application settings.\n        target_dir: Directory to save the image.\n        progress: Progress bar object.\n        task_id: Progress task ID.\n    \"\"\"\n    filename = f\"f{page_num:03d}{side}.jpg\"\n    file_path = target_dir / filename\n    log = logger.bind(manuscript_id=manuscript_id, filename=filename)\n\n    if file_path.exists():\n        progress.update(\n            task_id, advance=1, description=f\"[dim]Skipped {filename}[/dim]\"\n        )\n        log.info(\"page_skipped_exists\")\n        return\n\n    try:\n        width, height, tile_size = await get_file_info(\n            client, manuscript_id, filename, settings\n        )\n    except Exception as e:\n        progress.console.print(f\"[red]Error fetching info for {filename}: {e}[/red]\")\n        progress.update(task_id, advance=1)\n        return\n\n    columns_count = (width // tile_size) + 1\n    rows_count = (height // tile_size) + 1\n    zoom_level = 13\n    tile_url_template = f\"{settings.baseurl}{manuscript_id}_{filename.split('.')[0]}_files/{zoom_level}/{{}}_{{}}.jpg\"\n\n    page_image = Image.new(\"RGB\", (width, height))\n    sem = asyncio.Semaphore(5)\n\n    async def get_tile(u: str, col: int, row: int) -&gt; tuple[int, int, bytes]:\n        \"\"\"Fetch a single tile.\"\"\"\n        async with sem:\n            return col, row, await download_image(client, u)\n\n    tasks = [\n        get_tile(tile_url_template.format(c, r), c, r)\n        for c in range(columns_count)\n        for r in range(rows_count)\n    ]\n    results = await asyncio.gather(*tasks, return_exceptions=True)\n\n    failed_tiles = 0\n    for res in results:\n        if isinstance(res, BaseException):\n            failed_tiles += 1\n            continue\n\n        # res is now guaranteed to be tuple[int, int, bytes]\n        col, row, content = res\n        tile = Image.open(BytesIO(content))\n        page_image.paste(tile, (col * tile_size, row * tile_size))\n\n    if failed_tiles == 0:\n        page_image.save(file_path)\n        log.info(\"page_downloaded_success\")\n    else:\n        log.warning(\"page_downloaded_with_errors\", failed_tiles=failed_tiles)\n\n    progress.update(\n        task_id, advance=1, description=f\"[green]Downloaded {filename}[/green]\"\n    )\n</code></pre>"},{"location":"api/#configuration","title":"Configuration","text":""},{"location":"api/#bltools.settings","title":"<code>bltools.settings</code>","text":""},{"location":"api/#bltools.settings.Settings","title":"<code>Settings</code>","text":"<p>               Bases: <code>BaseSettings</code></p> <p>Application settings. Reads from environment variables (BLTOOLS_*) and .env file.</p> Source code in <code>src\\bltools\\settings.py</code> <pre><code>class Settings(BaseSettings):\n    \"\"\"\n    Application settings.\n    Reads from environment variables (BLTOOLS_*) and .env file.\n    \"\"\"\n\n    basedir: Path = Path(\".\")\n    sleeptime: float = 0.0\n    rangebegin: int = 1\n    rangeend: int = 259\n    baseurl: str = \"http://www.bl.uk/manuscripts/Proxy.ashx?view=\"\n\n    model_config = SettingsConfigDict(\n        env_prefix=\"BLTOOLS_\",\n        env_file=\".env\",\n        env_file_encoding=\"utf-8\",\n        extra=\"ignore\",\n    )\n</code></pre>"}]}