{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Welcome to bltools","text":"<p>Modern Async Downloader for British Library Manuscripts</p> <p><code>bltools</code> is a high-performance Python CLI tool designed to download manuscript images from the British Library's viewer. It utilizes <code>asyncio</code> and <code>httpx</code> for fast, parallel downloading and <code>Typer</code> for a robust command-line interface.</p>"},{"location":"#key-features","title":"Key Features","text":"<ul> <li>Blazing Fast: Uses <code>asyncio</code> + <code>httpx</code> to download tiles in parallel.</li> <li>Robust: Automatic retries with exponential backoff via <code>tenacity</code>.</li> <li>Beautiful: Rich terminal output with progress bars and spinners.</li> <li>Developer Friendly: Strictly typed, documented, and fully tested.</li> </ul>"},{"location":"#installation","title":"Installation","text":"<p>Requires Python 3.9+.</p>"},{"location":"#using-uv-recommended","title":"Using uv (Recommended)","text":"<pre><code>uv tool install bltools\n# or run directly\nuv run bltools --help\n</code></pre>"},{"location":"#using-pip","title":"Using pip","text":"<pre><code>pip install bltools\n</code></pre>"},{"location":"#quick-start","title":"Quick Start","text":"<p>Download pages 1 to 5 of a manuscript:</p> <pre><code>bltools download add_ms_19352 --range 1-5\n</code></pre> <p>Save to a specific directory:</p> <pre><code>bltools download add_ms_19352 --output ./downloads\n</code></pre>"},{"location":"api/","title":"API Reference","text":""},{"location":"api/#cli-application","title":"CLI Application","text":""},{"location":"api/#bltools.main","title":"<code>bltools.main</code>","text":""},{"location":"api/#bltools.main.download","title":"<code>download(manuscript_id=typer.Argument(..., help='The manuscript ID (e.g., add_ms_19352)'), config_path=typer.Option(Path('bl.conf'), '--config', '-c', help='Path to config file'), output_dir=typer.Option(None, '--output', '-o', help='Override output directory'), page_range=typer.Option(None, '--range', '-r', help='Page range (e.g., 1-10)'), verbose=typer.Option(False, '--verbose', '-v', help='Enable verbose logging'))</code>","text":"<p>Download a manuscript from the British Library.</p> Source code in <code>src\\bltools\\main.py</code> <pre><code>@app.command()\ndef download(\n    manuscript_id: str = typer.Argument(\n        ..., help=\"The manuscript ID (e.g., add_ms_19352)\"\n    ),\n    config_path: Path = typer.Option(\n        Path(\"bl.conf\"), \"--config\", \"-c\", help=\"Path to config file\"\n    ),\n    output_dir: Optional[Path] = typer.Option(\n        None, \"--output\", \"-o\", help=\"Override output directory\"\n    ),\n    page_range: Optional[str] = typer.Option(\n        None, \"--range\", \"-r\", help=\"Page range (e.g., 1-10)\"\n    ),\n    verbose: bool = typer.Option(\n        False, \"--verbose\", \"-v\", help=\"Enable verbose logging\"\n    ),\n) -&gt; None:\n    \"\"\"\n    Download a manuscript from the British Library.\n    \"\"\"\n    configure_logging(verbose=verbose)\n\n    config = BLConfig.load_from_file(config_path)\n\n    # Overrides\n    if output_dir:\n        config.basedir = output_dir\n\n    start, end = config.rangebegin, config.rangeend\n    if page_range:\n        try:\n            s, e = page_range.split(\"-\")\n            start, end = int(s), int(e)\n        except ValueError:\n            console.print(\"[red]Invalid range format. Use start-end (e.g., 1-10)[/red]\")\n            raise typer.Exit(code=1)\n\n    console.print(f\"[bold green]Starting download for {manuscript_id}[/bold green]\")\n    console.print(f\"Pages: {start} to {end}\")\n\n    asyncio.run(download_manuscript(manuscript_id, start, end, config, console))\n</code></pre>"},{"location":"api/#core-logic","title":"Core Logic","text":""},{"location":"api/#bltools.core","title":"<code>bltools.core</code>","text":""},{"location":"api/#bltools.core.download_manuscript","title":"<code>download_manuscript(manuscript_id, start, end, config, console)</code>  <code>async</code>","text":"<p>Main orchestrator for downloading a manuscript.</p> Source code in <code>src\\bltools\\core.py</code> <pre><code>async def download_manuscript(\n    manuscript_id: str, start: int, end: int, config: BLConfig, console: Console\n) -&gt; None:\n    \"\"\"\n    Main orchestrator for downloading a manuscript.\n    \"\"\"\n    log = logger.bind(manuscript_id=manuscript_id)\n    target_dir = config.basedir / manuscript_id\n    target_dir.mkdir(parents=True, exist_ok=True)\n\n    log.info(\n        \"starting_manuscript_download\",\n        start_page=start,\n        end_page=end,\n        target_dir=str(target_dir),\n    )\n\n    pages = []\n    for i in range(start, end + 1):\n        pages.append((i, \"r\"))\n        pages.append((i, \"v\"))\n\n    async with httpx.AsyncClient(\n        headers={\"User-Agent\": \"Mozilla/5.0\"}, timeout=30.0\n    ) as client:\n        with Progress(\n            SpinnerColumn(),\n            TextColumn(\"[progress.description]{task.description}\"),\n            BarColumn(),\n            console=console,\n        ) as progress:\n            total_files = len(pages)\n            main_task = progress.add_task(\n                \"[cyan]Downloading pages...\", total=total_files\n            )\n\n            chunk_size = 5  # Download 5 pages in parallel\n\n            for i in range(0, len(pages), chunk_size):\n                chunk = pages[i : i + chunk_size]\n                batch_tasks = [\n                    process_page(\n                        client,\n                        manuscript_id,\n                        p_num,\n                        p_side,\n                        config,\n                        target_dir,\n                        progress,\n                        main_task,\n                    )\n                    for p_num, p_side in chunk\n                ]\n                await asyncio.gather(*batch_tasks)\n\n    log.info(\"manuscript_download_complete\")\n</code></pre>"},{"location":"api/#bltools.core.download_tile","title":"<code>download_tile(client, url, row, col, sem)</code>  <code>async</code>","text":"<p>Download a single tile with retries.</p> Source code in <code>src\\bltools\\core.py</code> <pre><code>@retry(\n    stop=stop_after_attempt(5),\n    wait=wait_exponential(multiplier=1, min=1, max=10),\n    retry=retry_if_exception_type((httpx.RequestError, httpx.HTTPStatusError)),\n)\nasync def download_tile(\n    client: httpx.AsyncClient, url: str, row: int, col: int, sem: asyncio.Semaphore\n) -&gt; tuple[int, int, bytes]:\n    \"\"\"\n    Download a single tile with retries.\n    \"\"\"\n    async with sem:\n        # We don't log every tile download success to avoid spam, only failures/retries via tenacity if configured\n        response = await client.get(url)\n        response.raise_for_status()\n        return row, col, response.content\n</code></pre>"},{"location":"api/#bltools.core.get_file_info","title":"<code>get_file_info(client, base_url, manuscript_id, filename)</code>  <code>async</code>","text":"<p>Fetch the XML metadata for a page to determine dimensions and tile size.</p> Source code in <code>src\\bltools\\core.py</code> <pre><code>async def get_file_info(\n    client: httpx.AsyncClient, base_url: str, manuscript_id: str, filename: str\n) -&gt; tuple[int, int, int]:\n    \"\"\"\n    Fetch the XML metadata for a page to determine dimensions and tile size.\n    \"\"\"\n    info_url = f\"{base_url}{manuscript_id}_{filename.split('.')[0]}.xml\"\n    log = logger.bind(manuscript_id=manuscript_id, filename=filename, url=info_url)\n\n    log.debug(\"fetching_metadata\")\n    response = await client.get(info_url)\n    response.raise_for_status()\n\n    info_dict = xmltodict.parse(response.content)\n    try:\n        w = int(info_dict[\"Image\"][\"Size\"][\"@Width\"]) - 1\n        h = int(info_dict[\"Image\"][\"Size\"][\"@Height\"]) - 1\n        t = int(info_dict[\"Image\"][\"@TileSize\"])\n        log.debug(\"metadata_parsed\", width=w, height=h, tile_size=t)\n        return w, h, t\n    except (KeyError, ValueError) as e:\n        log.error(\"metadata_parse_failed\", error=str(e))\n        raise ValueError(f\"Failed to parse XML for {filename}: {e}\")\n</code></pre>"},{"location":"api/#bltools.core.process_page","title":"<code>process_page(client, manuscript_id, page_num, side, config, target_dir, progress, task_id)</code>  <code>async</code>","text":"<p>Process a single page: fetch metadata, download all tiles, stitch, and save.</p> Source code in <code>src\\bltools\\core.py</code> <pre><code>async def process_page(\n    client: httpx.AsyncClient,\n    manuscript_id: str,\n    page_num: int,\n    side: str,\n    config: BLConfig,\n    target_dir: Path,\n    progress: Progress,\n    task_id: TaskID,\n) -&gt; None:\n    \"\"\"\n    Process a single page: fetch metadata, download all tiles, stitch, and save.\n    \"\"\"\n    filename = f\"f{page_num:03d}{side}.jpg\"\n    file_path = target_dir / filename\n    log = logger.bind(manuscript_id=manuscript_id, filename=filename)\n\n    if file_path.exists():\n        progress.update(\n            task_id, advance=1, description=f\"[dim]Skipped {filename}[/dim]\"\n        )\n        log.info(\"page_skipped_exists\")\n        return\n\n    try:\n        width, height, tile_size = await get_file_info(\n            client, config.baseurl, manuscript_id, filename\n        )\n    except Exception as e:\n        # Already logged in get_file_info\n        progress.console.print(f\"[red]Error fetching info for {filename}: {e}[/red]\")\n        progress.update(task_id, advance=1)\n        return\n\n    rows = (width // tile_size) + 1\n    cols = (height // tile_size) + 1\n    zoom_level = 13\n\n    tile_url_template = f\"{config.baseurl}{manuscript_id}_{filename.split('.')[0]}_files/{zoom_level}/{{}}_{{}}.jpg\"\n\n    # Create blank image\n    page_image = Image.new(\"RGB\", (width, height))\n\n    # Prepare tile tasks\n    sem = asyncio.Semaphore(10)  # Concurrency limit for tiles per page\n    tasks = []\n\n    log.debug(\"starting_tile_downloads\", total_tiles=rows * cols)\n    for r in range(rows):\n        for c in range(cols):\n            url = tile_url_template.format(r, c)\n            tasks.append(download_tile(client, url, r, c, sem))\n\n    results = await asyncio.gather(*tasks, return_exceptions=True)\n\n    failed_tiles = 0\n    for res in results:\n        if isinstance(res, Exception):\n            log.warning(\"tile_download_failed\", error=str(res))\n            failed_tiles += 1\n            continue\n\n        r, c, content = res\n        try:\n            tile = Image.open(BytesIO(content))\n            box = (r * tile_size, c * tile_size)\n            page_image.paste(tile, box)\n        except Exception as e:\n            log.error(\"tile_processing_failed\", error=str(e))\n            failed_tiles += 1\n\n    if failed_tiles &gt; 0:\n        log.warning(\"page_downloaded_with_errors\", failed_tiles=failed_tiles)\n    else:\n        log.info(\"page_downloaded_success\")\n\n    page_image.save(file_path)\n    progress.update(\n        task_id, advance=1, description=f\"[green]Downloaded {filename}[/green]\"\n    )\n</code></pre>"},{"location":"api/#configuration","title":"Configuration","text":""},{"location":"api/#bltools.config","title":"<code>bltools.config</code>","text":""}]}